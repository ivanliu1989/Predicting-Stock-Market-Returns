hear(TAP.AX[, c("High", "Low")])
head(TAP.AX[, c("High", "Low")])
head(TAP.AX[, c("High", "Low")])
head(TAP.AX[, "Volume"])
EMV(x[, c("High", "Low")], x[, "Volume"])
EMV(TAP.AX[, c("High", "Low")], TAP.AX[, "Volume"])
sum(is.na(TAP.AX[,"High"]))
sum(is.na(TAP.AX[,"Low"]))
sum(is.na(TAP.AX[,"Volume"]))
head(TAP.AX[,"Volume"])
head(TAP.AX[,"Volume"],n=100)
head(GSPC[,"Volume"],n=100)
sum(GSPC$Volumn==0)
sum(TAP.AX$Volumn==0)
TAP.AX$Volumn
sum(GSPC$Volume==0)
sum(TAP.AX$Volume==0)
TAP.AX$Volume <- TAP.AX$Volume +1
sum(TAP.AX$Volume==0)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["1999-12-31"])),
ntree=50, importance=T)
head(TAP.AX)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
setwd("C:\\Documents and Settings\\Macro\\Desktop\\Ivandata\\Predicting-Stock-Market-Returns")
library(xts)
## As the function get.hist.quote() returns an object of class zoo, we have
## again used the function as.xts() to coerce it to xts.
#     library(tseries)
#     TAP.AX <- as.xts(get.hist.quote("TAP.AX",start="1970-01-02", # end="2009-09-15",
#                                   quote=c("Open", "High", "Low", "Close","Volume","AdjClose")))
#     TAP.AX[c(1,nrow(GSPC))]
## quantmod
library(quantmod)
#     getSymbols("TAP.AX", from = "1970-01-01", to = "2009-09-15")
setSymbolLookup(TAP=list(name='TAP.AX',src='yahoo'),
IBM=list(name='IBM',src='yahoo'),
USDEUR=list(name='USD/EUR',src='oanda'))
getSymbols(c('TAP.AX'))
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
head(TAP.AX)
#     saveSymbolLookup()
#     loadSymbolLookup()
## indicator function
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
# newTA() can be used to create new
# plotting functions for indicators that we wish to include in candlestick graphs.
png("TAP.png")
candleChart(last(TAP.AX, "3 months"), theme = "white", TA = NULL)
avgPrice <- function(p) apply(HLC(p), 1, mean)
addAvgPrice <- newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind <- newTA(FUN = T.ind, col = "red", legend = "tgtRet")
addAvgPrice(on = 1)
addT.ind()
dev.off()
# a representative set of technical indicators, from those available in package TTR
library(TTR)
myATR <- function(x) ATR(HLC(x))[, "atr"]
mySMI <- function(x) SMI(HLC(x))[, "SMI"]
myADX <- function(x) ADX(HLC(x))[, "ADX"]
myAroon <- function(x) aroon(x[, c("High", "Low")])$oscillator
myBB <- function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol <- function(x) Delt(chaikinVolatility(x[, c("High", "Low")]))[, 1]
myCLV <- function(x) EMA(CLV(HLC(x)))[, 1]
myEMV <- function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD <- function(x) MACD(Cl(x))[, 2]
myMFI <- function(x) MFI(x[, c("High", "Low", "Close")], x[, "Volume"])
mySAR <- function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat <- function(x) volatility(OHLC(x), calc = "garman")[,1]
# Build a random forest using the data available for training:
library(randomForest)
TAP.AX <- HLC(TAP.AX)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
TAP.AX
setwd("C:\\Documents and Settings\\Macro\\Desktop\\Ivandata\\Predicting-Stock-Market-Returns")
library(xts)
## As the function get.hist.quote() returns an object of class zoo, we have
## again used the function as.xts() to coerce it to xts.
#     library(tseries)
#     TAP.AX <- as.xts(get.hist.quote("TAP.AX",start="1970-01-02", # end="2009-09-15",
#                                   quote=c("Open", "High", "Low", "Close","Volume","AdjClose")))
#     TAP.AX[c(1,nrow(GSPC))]
## quantmod
library(quantmod)
#     getSymbols("TAP.AX", from = "1970-01-01", to = "2009-09-15")
setSymbolLookup(TAP=list(name='TAP.AX',src='yahoo'),
IBM=list(name='IBM',src='yahoo'),
USDEUR=list(name='USD/EUR',src='oanda'))
getSymbols(c('TAP.AX'))
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
head(TAP.AX)
#     saveSymbolLookup()
#     loadSymbolLookup()
## indicator function
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
# newTA() can be used to create new
# plotting functions for indicators that we wish to include in candlestick graphs.
png("TAP.png")
candleChart(last(TAP.AX, "3 months"), theme = "white", TA = NULL)
avgPrice <- function(p) apply(HLC(p), 1, mean)
addAvgPrice <- newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind <- newTA(FUN = T.ind, col = "red", legend = "tgtRet")
addAvgPrice(on = 1)
addT.ind()
dev.off()
# a representative set of technical indicators, from those available in package TTR
library(TTR)
myATR <- function(x) ATR(HLC(x))[, "atr"]
mySMI <- function(x) SMI(HLC(x))[, "SMI"]
myADX <- function(x) ADX(HLC(x))[, "ADX"]
myAroon <- function(x) aroon(x[, c("High", "Low")])$oscillator
myBB <- function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol <- function(x) Delt(chaikinVolatility(x[, c("High", "Low")]))[, 1]
myCLV <- function(x) EMA(CLV(HLC(x)))[, 1]
myEMV <- function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD <- function(x) MACD(Cl(x))[, 2]
myMFI <- function(x) MFI(x[, c("High", "Low", "Close")], x[, "Volume"])
mySAR <- function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat <- function(x) volatility(OHLC(x), calc = "garman")[,1]
# Build a random forest using the data available for training:
library(randomForest)
TAP.AX$Volumn <- TAP.AX$Volumn+0.000000001
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
TAP.AX$Volume <- TAP.AX$Volume+0.000000001
TAP.AX
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
?specifyModel
ex.model <- specifyModel(T.ind(IBM) ~ Delt(Cl(IBM), k = 1:3))
data <- modelData(ex.model, data.window = c("2009-01-01", "2009-08-10"))
data
varImpPlot(rf@fitted.model, type = 1)
varImpPlot(rf@fitted.model, type = 1)
imp <- varImpPlot(rf@fitted.model, type = 1) #
rownames(imp)[which(imp > 10)]
imp <- importance(rf@fitted.model, type = 1)
rownames(imp)[which(imp > 10)]
Tdata.train <- as.data.frame(modelData(data.model, data.window=c('1970-01-02','2012-12-31')))
Tdata.eval <- na.omit(as.data.frame(modelData(data.model, data.window=c('2012-12-31','2014-08-18'))))
head(Tdata.train)
head(Tdata.eval)
Tdata.eval <- na.omit(as.data.frame(modelData(data.model, data.window=c('2013-01-01','2014-08-18'))))
Tform <- as.formula('T.ind.TAP.AX ~ .')
Tform
set.seed(1234)
library(nnet)
norm.data <- scale(Tdata.train)
head(norm.data)
nn <- nnet(Tform, norm.data[1:1000, ], size = 10, decay = 0.01,maxit = 1000, linout = T, trace = F)
norm.preds <- predict(nn, norm.data[1001:2000, ])
norm.preds <- predict(nn, norm.data[1001:1900, ])
norm.data
norm.preds <- predict(nn, norm.data[1001:nrow(norm.data), ])
preds <- unscale(norm.preds, norm.data)
preds <- rescale(norm.preds, norm.data)
?scale
?unscale
install.packages("DMwR")
library(DMwR)
preds <- unscale(norm.preds, norm.data)
setwd("C:\\Documents and Settings\\Macro\\Desktop\\Ivandata\\Predicting-Stock-Market-Returns")
library(xts)
## As the function get.hist.quote() returns an object of class zoo, we have
## again used the function as.xts() to coerce it to xts.
#     library(tseries)
#     TAP.AX <- as.xts(get.hist.quote("TAP.AX",start="1970-01-02", # end="2009-09-15",
#                                   quote=c("Open", "High", "Low", "Close","Volume","AdjClose")))
#     TAP.AX[c(1,nrow(GSPC))]
## quantmod
library(quantmod)
#     getSymbols("TAP.AX", from = "1970-01-01", to = "2009-09-15")
setSymbolLookup(TAP=list(name='TAP.AX',src='yahoo'),
IBM=list(name='IBM',src='yahoo'),
USDEUR=list(name='USD/EUR',src='oanda'))
getSymbols(c('TAP.AX'))
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
head(TAP.AX)
#     saveSymbolLookup()
#     loadSymbolLookup()
## indicator function
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
# newTA() can be used to create new
# plotting functions for indicators that we wish to include in candlestick graphs.
png("TAP.png")
candleChart(last(TAP.AX, "3 months"), theme = "white", TA = NULL)
avgPrice <- function(p) apply(HLC(p), 1, mean)
addAvgPrice <- newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind <- newTA(FUN = T.ind, col = "red", legend = "tgtRet")
addAvgPrice(on = 1)
addT.ind()
dev.off()
# a representative set of technical indicators, from those available in package TTR
library(TTR)
myATR <- function(x) ATR(HLC(x))[, "atr"]
mySMI <- function(x) SMI(HLC(x))[, "SMI"]
myADX <- function(x) ADX(HLC(x))[, "ADX"]
myAroon <- function(x) aroon(x[, c("High", "Low")])$oscillator
myBB <- function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol <- function(x) Delt(chaikinVolatility(x[, c("High", "Low")]))[, 1]
myCLV <- function(x) EMA(CLV(HLC(x)))[, 1]
myEMV <- function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD <- function(x) MACD(Cl(x))[, 2]
myMFI <- function(x) MFI(x[, c("High", "Low", "Close")], x[, "Volume"])
mySAR <- function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat <- function(x) volatility(OHLC(x), calc = "garman")[,1]
# Build a random forest using the data available for training:
library(randomForest)
TAP.AX$Volume <- TAP.AX$Volume+0.000000001
# specifyModel - Create a single reusable model specification for subsequent buildModel calls. a quantmod object.
# getModelData() to obtain a refresh of the object (data.model)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
# The function buildModel() uses the resulting model specication
# and obtains a model with the corresponding data.
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
# IBM
ex.model <- specifyModel(T.ind(IBM) ~ Delt(Cl(IBM), k = 1:3))
# obtain the data using the function modelData()
# and use it with your favorite modeling function
data <- modelData(ex.model, data.window = c("2009-01-01", "2009-08-10"))
# m <- myFavouriteModellingTool(ex.model@model.formula, as.data.frame(data))
# The generic function buildModel() returns the obtained model as a slot (fitted.model) of the quantmod object it produces
varImpPlot(rf@fitted.model, type = 1)
imp <- importance(rf@fitted.model, type = 1) # obtains the concrete scores for each variable
rownames(imp)[which(imp > 10)]
# signal = sell(T < -0.1), hold, buy(T > -0.1), trading.signals() in book package
Tdata.train <- as.data.frame(modelData(data.model, data.window=c('1970-01-02','2012-12-31')))
Tdata.eval <- na.omit(as.data.frame(modelData(data.model, data.window=c('2013-01-01','2014-08-18'))))
Tform <- as.formula('T.ind.TAP.AX ~ .')
# Scale data scale(),unscale()
set.seed(1234)
library(nnet)
library(DMwR)
norm.data <- scale(Tdata.train)
nn <- nnet(Tform, norm.data[1:1000, ], size = 10, decay = 0.01,maxit = 1000, linout = T, trace = F)
norm.preds <- predict(nn, norm.data[1001:nrow(norm.data), ])
preds <- unscale(norm.preds, norm.data)
cg()
cf()
sigs.nn <- trading.signals(preds, 0.1, -0.1)
sigs.nn
true.sigs <- trading.signals(Tdata.train[1001:2000, "T.ind.GSPC"],0.1, -0.1)
true.sigs
true.sigs <- trading.signals(Tdata.train[1001:nrow(Tdata.train), "T.ind.GSPC"],0.1, -0.1)
true.sigs
true.sigs <- trading.signals(Tdata.train[1001:nrow(norm.data), "T.ind.GSPC"],0.1, -0.1)
true.sigs <- trading.signals(Tdata.train[1001:nrow(norm.data), "T.ind.GSPC"],0.1, -0.1)
true.sigs
sigs.PR(sigs.nn, true.sigs)
nrow(norm.data)
true.sigs <- trading.signals(Tdata.train[1001:1522, "T.ind.GSPC"],0.1, -0.1)
true.sigs
true.sigs <- trading.signals(Tdata.train[1001:1522, "T.ind.TAP.AX"],0.1, -0.1)
sigs.PR(sigs.nn, true.sigs)
true.sigs <- trading.signals(Tdata.train[1001:nrow(Tdata.train), "T.ind.TAP.AX"],0.1, -0.1)
sigs.PR(sigs.nn, true.sigs)
set.seed(1234)
signals <- trading.signals(Tdata.train[, "T.ind.GSPC"], 0.1,-0.1)
signals <- trading.signals(Tdata.train[, "T.ind.TAP.AX"], 0.1,-0.1)
norm.data <- data.frame(signals = signals, scale(Tdata.train[,-1]))
nn <- nnet(signals ~ ., norm.data[1:1000, ], size = 10, decay = 0.01,maxit = 1000, trace = F)
preds <- predict(nn, norm.data[1001:2000, ], type = "class")
preds
preds <- predict(nn, norm.data[1001:nrow(norm.data), ], type = "class")
preds
sigs.PR(preds, norm.data[1001:nrow(norm.data), 1])
library(e1071)
sv <- svm(Tform, Tdata.train[1:1000, ], gamma = 0.001, cost = 100)
s.preds <- predict(sv, Tdata.train[1001:nrow(Tdata.train), ])
sigs.svm <- trading.signals(s.preds, 0.1, -0.1)
true.sigs <- trading.signals(Tdata.train[1001:nrow(Tdata.train), "T.ind.TAP.AX"],0.1, -0.1)
sigs.PR(sigs.svm, true.sigs)
?svm
sv <- svm(Tform, Tdata.train[1:1000, ], gamma = 0.001, cost = 10)
s.preds <- predict(sv, Tdata.train[1001:nrow(Tdata.train), ])
sigs.svm <- trading.signals(s.preds, 0.1, -0.1)
true.sigs <- trading.signals(Tdata.train[1001:nrow(Tdata.train), "T.ind.TAP.AX"],0.1, -0.1)
sigs.PR(sigs.svm, true.sigs)
sv <- svm(Tform, Tdata.train[1:1000, ], gamma = 0.001, cost = 1000)
s.preds <- predict(sv, Tdata.train[1001:nrow(Tdata.train), ])
sigs.svm <- trading.signals(s.preds, 0.1, -0.1)
true.sigs <- trading.signals(Tdata.train[1001:nrow(Tdata.train), "T.ind.TAP.AX"],0.1, -0.1)
sigs.PR(sigs.svm, true.sigs)
library(kernlab)
data <- cbind(signals = signals, Tdata.train[, -1])
data
Tdata.train[, -1]
ksv <- ksvm(signals ~ ., data[1:1000, ], C = 10)
data <- cbind(signals = signals, Tdata.train[, -1])
ksv <- ksvm(signals ~ ., data[1:1000, ], C = 10)
ks.preds <- predict(ksv, data[1001:2000, ])
ks.preds <- predict(ksv, data[1001:nrow(data), ])
sigs.PR(ks.preds, data[1001:nrow(data), 1])
library(earth)
e <- earth(Tform, Tdata.train[1:1000, ])
e.preds <- predict(e, Tdata.train[1001:nrow(Tdata.train), ])
sigs.e <- trading.signals(e.preds, 0.1, -0.1)
true.sigs <- trading.signals(Tdata.train[1001:nrow(Tdata.train), "T.ind.TAP.AX"],0.1, -0.1)
sigs.PR(sigs.e, true.sigs)
start <- 1
len.tr <- 1000
len.ts <- 500
tr <- start:(start+len.tr-1)
tr
ts <- (start+len.tr):(start+len.tr+len.ts-1)
ts
library(quantmod)
setSymbolLookup(IBM=list(name='IBM',src='yahoo'))
getSymbols(c('IBM'))
colnames(IBM) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
head(IBM)
date <- rownames(Tdata.train[start+len.tr,])
head(date)
date
market <- IBM[paste(date,'/',sep='')][1:len.ts]
market
paste(date,'/',sep='')
IBM[paste(date,'/',sep='')]
nrow(IBM[paste(date,'/',sep='')])
market <- IBM[paste(date,'/',sep='')][1:len.ts]
market
nrow(market)
?Tform
Tdata.train[tr,]
s <- svm(Tform,Tdata.train[tr,],cost=10,gamma=0.01)
p <- predict(s,Tdata.train[ts,])
sig <- trading.signals(p,0.1,-0.1)
t1 <- trading.simulator(market,sig,'policy.1',list(exp.prof=0.05,bet=0.2,hold.time=30))
source("Trading policy.R")
t1 <- trading.simulator(market,sig,'policy.1',list(exp.prof=0.05,bet=0.2,hold.time=30))
sig
t1
summary(t1)
tradingEvaluation(t1)
plot(t1, market, theme = "white", name = "SP500")
source("Trading policy2.R")
t2 <- trading.simulator(market, sig, "policy.2", list(exp.prof = 0.05, bet = 0.3))
summary(t2)
tradingEvaluation(t2)
plot(t2, market, theme = "white", name = "SP500")
plot(t1, market, theme = "white", name = "SP500")
gc()
# Train and test periods
start <- 2000
len.tr <- 1000
len.ts <- 500
tr <- start:(start+len.tr-1)
ts <- (start+len.tr):(start+len.tr+len.ts-1)
# getting the quotes for the testing period
library(quantmod)
setSymbolLookup(IBM=list(name='IBM',src='yahoo'))
getSymbols(c('IBM'))
colnames(IBM) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
date <- rownames(Tdata.train[start+len.tr,])
market <- IBM[paste(date,'/',sep='')][1:len.ts]
# Train and test periods
start <- 1
len.tr <- 1000
len.ts <- 500
tr <- start:(start+len.tr-1)
ts <- (start+len.tr):(start+len.tr+len.ts-1)
# getting the quotes for the testing period
library(quantmod)
setSymbolLookup(IBM=list(name='IBM',src='yahoo'))
getSymbols(c('IBM'))
colnames(IBM) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
date <- rownames(Tdata.train[start+len.tr,])
market <- IBM[paste(date,'/',sep='')][1:len.ts]
# learning the model and obtaining its signal predictions
library(e1071)
s <- svm(Tform,Tdata.train[tr,],cost=10,gamma=0.01)
p <- predict(s,Tdata.train[ts,])
sig <- trading.signals(p,0.1,-0.1)
# now using the simulated trader
source("Trading policy.R")
t1 <- trading.simulator(market,sig,'policy.1',list(exp.prof=0.05,bet=0.2,hold.time=30))
t1
summary(t1)
tradingEvaluation(t1)
plot(t1, market, theme = "white", name = "SP500")
source("Trading policy2.R")
t2 <- trading.simulator(market, sig, "policy.2", list(exp.prof = 0.05, bet = 0.3))
summary(t2)
tradingEvaluation(t2)
plot(t2, market, theme = "white", name = "SP500")
source("Trading policy.R")
t1 <- trading.simulator(market,sig,'policy.1',list(exp.prof=0.05,bet=0.2,hold.time=30))
t1
summary(t1)
tradingEvaluation(t1)
plot(t1, market, theme = "white", name = "SP500")
t1 <- trading.simulator(market,sig,'policy.1',list(exp.prof=0.05,bet=0.2,hold.time=30))
rm(ls())
rm(ls(All=T))
rm(ls(all=T))
ls()
rm(c(ls()))
rm(ls())
rm(list(ls()))
rm(list=ls())
start <- 2000
len.tr <- 1000
len.ts <- 500
tr <- start:(start+len.tr-1)
ts <- (start+len.tr):(start+len.tr+len.ts-1)
library(quantmod)
setSymbolLookup(IBM=list(name='IBM',src='yahoo'))
getSymbols(c('IBM'))
colnames(IBM) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
library(TTR)
myATR <- function(x) ATR(HLC(x))[, "atr"]
mySMI <- function(x) SMI(HLC(x))[, "SMI"]
myADX <- function(x) ADX(HLC(x))[, "ADX"]
myAroon <- function(x) aroon(x[, c("High", "Low")])$oscillator
myBB <- function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol <- function(x) Delt(chaikinVolatility(x[, c("High", "Low")]))[, 1]
myCLV <- function(x) EMA(CLV(HLC(x)))[, 1]
myEMV <- function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD <- function(x) MACD(Cl(x))[, 2]
myMFI <- function(x) MFI(x[, c("High", "Low", "Close")], x[, "Volume"])
mySAR <- function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat <- function(x) volatility(OHLC(x), calc = "garman")[,1]
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
