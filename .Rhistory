apply(HLC(TAP.AX), 1, mean)
v <- apply(HLC(TAP.AX), 1, mean)
r <- matrix(NA, ncol = 10, nrow = nrow(TAP.AX))
r
r[, 1] <- Next(Delt(v, k = 1), 1)
r
r[, 2] <- Next(Delt(v, k = 2), 2)
head(r)
Delt(v, k = 2)
head(Delt(v, k = 2))
head(Delt(v, k = 1))
head(Delt(v, k = 0))
head(Delt(v, k = 3))
Next(Delt(v, k = 3), 3)
head(Delt(v, k = 3))
head(Next(Delt(v, k = 3), 3))
head(Next(Delt(v, k = 3), 2))
head(Next(Delt(v, k = 3)))
time(TAP.AX)
head(TAP.AX)
head(v)
head(Delt(v))
head(Delt(v,2))
head(Delt(v,k=2))
for (x in 1:10) r[, x] <- Next(Delt(v, k = x), x)
tail(r)
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
?candleChart
?last
last(TAP.AX, "3 months")
candleChart(last(TAP.AX, "3 months"), theme = "white", TA = NULL)
avgPrice <- function(p) apply(HLC(p), 1, mean)
addAvgPrice <- newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind <- newTA(FUN = T.ind, col = "red", legend = "tgtRet")
addAvgPrice(on = 1)
addT.ind()
png("TAP.png")
candleChart(last(TAP.AX, "3 months"), theme = "white", TA = NULL)
avgPrice <- function(p) apply(HLC(p), 1, mean)
addAvgPrice <- newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind <- newTA(FUN = T.ind, col = "red", legend = "tgtRet")
addAvgPrice(on = 1)
addT.ind()
dev.off()
library(TTR)
myATR <- function(x) ATR(HLC(x))[, "atr"]
mySMI <- function(x) SMI(HLC(x))[, "SMI"]
myADX <- function(x) ADX(HLC(x))[, "ADX"]
myAroon <- function(x) aroon(x[, c("High", "Low")])$oscillator
myBB <- function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol <- function(x) Delt(chaikinVolatility(x[, c("High", "Low")]))[, 1]
myCLV <- function(x) EMA(CLV(HLC(x)))[, 1]
myEMV <- function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD <- function(x) MACD(Cl(x))[, 2]
myMFI <- function(x) MFI(x[, c("High", "Low", "Close")], x[, "Volume"])
mySAR <- function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat <- function(x) volatility(OHLC(x), calc = "garman")[,1]
library(randomForest)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
head(TAP.AX)
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "AdjClose")
head(TAP.AX)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
T.ind(TAP.AX)
Cl(TAP.AX)
head(Cl(TAP.AX))
?Cl
Delt(Cl(TAP.AX),k=1:10)
Delt(Cl(TAP.AX),k=10)
Delt(Cl(TAP.AX),k=2)
head(Cl(TAP.AX))
head(Cl(TAP.AX)[,1:2])
head(myATR(TAP.AX))
myATR(TAP.AX)
mySMI(TAP.AX)
TAP.AX <- HLC(TAP.AX)
Delt(Cl(TAP.AX),k=1:10)
Cl(TAP.AX)
head(Cl(TAP.AX))
head(TAP.AX)
mySMI(TAP.AX)
myADX(TAP.AX)
head(myADX(TAP.AX))
head(myAroon(TAP.AX))
head(myBB(TAP.AX))
head(myChaikinVol(TAP.AX))
head(myCLV(TAP.AX))
CMO(Cl(TAP.AX))
EMA(Delt(Cl(TAP.AX)))
myEMV(TAP.AX)
myVolat(TAP.AX)
myMACD(TAP.AX)
ex.model <- specifyModel(T.ind(IBM) ~ Delt(Cl(IBM), k = 1:3))
data <- modelData(ex.model, data.window = c("2009-01-01", "2009-08-10"))
m <- myFavouriteModellingTool(ex.model@model.formula, as.data.frame(data))
data
setwd("C:\\Documents and Settings\\Macro\\Desktop\\Ivandata\\Predicting-Stock-Market-Returns")
library(xts)
data(GSPC)
load("C:/Documents and Settings/Macro/Desktop/Ivandata/Predicting-Stock-Market-Returns/GSPC.RData")
setwd("C:\\Documents and Settings\\Macro\\Desktop\\Ivandata\\Predicting-Stock-Market-Returns")
library(xts)
data(GSPC)
GSPC
head9
head(GSPC)
T.ind <- function(quotes,tgt.margin=0.025,n.days=10) {
v <- apply(HLC(quotes),1,mean)
r <- matrix(NA,ncol=n.days,nrow=NROW(quotes))
## The following statment is wrong in the book (page 109)!
for(x in 1:n.days) r[,x] <- Next(Delt(Cl(quotes),v,k=x),x)
x <- apply(r,1,function(x) sum(x[x > tgt.margin | x < -tgt.margin]))
if (is.xts(quotes)) xts(x,time(quotes)) else x
}
candleChart(last(GSPC,'3 months'),theme='white',TA=NULL)
avgPrice <- function(p) apply(HLC(p),1,mean)
addAvgPrice <- newTA(FUN=avgPrice,col=1,legend='AvgPrice')
addT.ind <- newTA(FUN=T.ind,col='red',legend='tgtRet')
addAvgPrice(on=1)
addT.ind()
library(quantmod)
T.ind <- function(quotes,tgt.margin=0.025,n.days=10) {
v <- apply(HLC(quotes),1,mean)
r <- matrix(NA,ncol=n.days,nrow=NROW(quotes))
## The following statment is wrong in the book (page 109)!
for(x in 1:n.days) r[,x] <- Next(Delt(Cl(quotes),v,k=x),x)
x <- apply(r,1,function(x) sum(x[x > tgt.margin | x < -tgt.margin]))
if (is.xts(quotes)) xts(x,time(quotes)) else x
}
candleChart(last(GSPC,'3 months'),theme='white',TA=NULL)
avgPrice <- function(p) apply(HLC(p),1,mean)
addAvgPrice <- newTA(FUN=avgPrice,col=1,legend='AvgPrice')
addT.ind <- newTA(FUN=T.ind,col='red',legend='tgtRet')
addAvgPrice(on=1)
addT.ind()
myATR <- function(x) ATR(HLC(x))[,'atr']
mySMI <- function(x) SMI(HLC(x))[,'SMI']
myADX <- function(x) ADX(HLC(x))[,'ADX']
myAroon <- function(x) aroon(x[,c('High','Low')])$oscillator
myBB <- function(x) BBands(HLC(x))[,'pctB']
myChaikinVol <- function(x) Delt(chaikinVolatility(x[,c("High","Low")]))[,1]
myCLV <- function(x) EMA(CLV(HLC(x)))[,1]
myEMV <- function(x) EMV(x[,c('High','Low')],x[,'Volume'])[,2]
myMACD <- function(x) MACD(Cl(x))[,2]
myMFI <- function(x) MFI(x[,c("High","Low","Close")], x[,"Volume"])
mySAR <- function(x) SAR(x[,c('High','Close')]) [,1]
myVolat <- function(x) volatility(OHLC(x),calc="garman")[,1]
library(randomForest)
data.model <- specifyModel(T.ind(GSPC) ~ Delt(Cl(GSPC),k=1:10) +
myATR(GSPC) + mySMI(GSPC) + myADX(GSPC) + myAroon(GSPC) +
myBB(GSPC)  + myChaikinVol(GSPC) + myCLV(GSPC) +
CMO(Cl(GSPC)) + EMA(Delt(Cl(GSPC))) + myEMV(GSPC) +
myVolat(GSPC)  + myMACD(GSPC) + myMFI(GSPC) + RSI(Cl(GSPC)) +
mySAR(GSPC) + runMean(Cl(GSPC)) + runSD(Cl(GSPC)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(GSPC),index(GSPC["1999-12-31"])),
ntree=50, importance=T)
varImpPlot(rf@fitted.model,type=1)
imp <- importance(rf@fitted.model,type=1)
rownames(imp)[which(imp > 10)]
data.model <- specifyModel(T.ind(GSPC) ~ Delt(Cl(GSPC),k=1) + myATR(GSPC)
+ myADX(GSPC) +    myEMV(GSPC) + myVolat(GSPC)  + myMACD(GSPC)
+ mySAR(GSPC) + runMean(Cl(GSPC)) )
Tdata.train <- as.data.frame(modelData(data.model,
data.window=c('1970-01-02','1999-12-31')))
Tdata.eval <- na.omit(as.data.frame(modelData(data.model,
data.window=c('2000-01-01','2009-09-15'))))
Tform <- as.formula('T.ind.GSPC ~ .')
Tform
Delt(Cl(GSPC),k=1:10)
head(Cl(GSPC))
head(GSPC)
TAP.AX
getSymbols("TAP.AX", from = "1970-01-01", to = "2009-09-15")
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "AdjClose")
head(TAP.AX)
head(TAP.AX)
head(GSPC)
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
head(TAP.AX)
head(Cl(TAP.AX))
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "AdjClose")
head(Cl(TAP.AX))
setSymbolLookup(TAP=list(name='TAP.AX',src='yahoo'),
IBM=list(name='IBM',src='yahoo'),
USDEUR=list(name='USD/EUR',src='oanda'))
getSymbols(c('TAP.AX'))
head(TAP.AX)
head(Cl(TAP.AX))
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
# newTA() can be used to create new
# plotting functions for indicators that we wish to include in candlestick graphs.
png("TAP.png")
candleChart(last(TAP.AX, "3 months"), theme = "white", TA = NULL)
avgPrice <- function(p) apply(HLC(p), 1, mean)
addAvgPrice <- newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind <- newTA(FUN = T.ind, col = "red", legend = "tgtRet")
addAvgPrice(on = 1)
addT.ind()
dev.off()
# a representative set of technical indicators, from those available in package TTR
library(TTR)
myATR <- function(x) ATR(HLC(x))[, "atr"]
mySMI <- function(x) SMI(HLC(x))[, "SMI"]
myADX <- function(x) ADX(HLC(x))[, "ADX"]
myAroon <- function(x) aroon(x[, c("High", "Low")])$oscillator
myBB <- function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol <- function(x) Delt(chaikinVolatility(x[, c("High", "Low")]))[, 1]
myCLV <- function(x) EMA(CLV(HLC(x)))[, 1]
myEMV <- function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD <- function(x) MACD(Cl(x))[, 2]
myMFI <- function(x) MFI(x[, c("High", "Low", "Close")], x[, "Volume"])
mySAR <- function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat <- function(x) volatility(OHLC(x), calc = "garman")[,1]
library(randomForest)
TAP.AX <- HLC(TAP.AX)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
Delt(Cl(TAP.AX),k=1:10)
myATR(TAP.AX)
mySMI(TAP.AX)
myADX(TAP.AX)
myAroon(TAP.AX)
myBB(TAP.AX)
myChaikinVol(TAP.AX)
myCLV(TAP.AX)
CMO(Cl(TAP.AX))
EMA(Delt(Cl(TAP.AX)))
myEMV(TAP.AX)
myVolat(TAP.AX)
myMACD(TAP.AX)
myMFI(TAP.AX)
class(TAP.AX)
class(GSPC)
class(Cl(GSPC))
class(Cl(TAP.AX))
head(TAP.AX)
head(GSPC.AX)
head(GSPC)
myMFI(TAP.AX)
getSymbols(c('TAP.AX'))
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
head(TAP.AX)
myMFI(TAP.AX)
myEMV(TAP.AX)
myVolat(TAP.AX)
myMACD(TAP.AX)
EMA(Delt(Cl(TAP.AX)))
CMO(Cl(TAP.AX))
myCLV(TAP.AX)
RSI(Cl(TAP.AX))
runSD(Cl(TAP.AX))
runMean(Cl(TAP.AX))
mySAR(TAP.AX)
Delt(Cl(TAP.AX),k=1:10)
myEMV(TAP.AX)
myCLV(TAP.AX)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
EMA(Delt(Cl(TAP.AX)))
head(TAP.AX)
myEMV(TAP.AX)
sum(is.na(TAP.AX))
EMV(TAP.AX[, c("High", "Low")], TAP.AX[, "Volume"])[,2]
TAP.AX[, c("High", "Low")]
hear(TAP.AX[, c("High", "Low")])
head(TAP.AX[, c("High", "Low")])
head(TAP.AX[, c("High", "Low")])
head(TAP.AX[, "Volume"])
EMV(x[, c("High", "Low")], x[, "Volume"])
EMV(TAP.AX[, c("High", "Low")], TAP.AX[, "Volume"])
sum(is.na(TAP.AX[,"High"]))
sum(is.na(TAP.AX[,"Low"]))
sum(is.na(TAP.AX[,"Volume"]))
head(TAP.AX[,"Volume"])
head(TAP.AX[,"Volume"],n=100)
head(GSPC[,"Volume"],n=100)
sum(GSPC$Volumn==0)
sum(TAP.AX$Volumn==0)
TAP.AX$Volumn
sum(GSPC$Volume==0)
sum(TAP.AX$Volume==0)
TAP.AX$Volume <- TAP.AX$Volume +1
sum(TAP.AX$Volume==0)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["1999-12-31"])),
ntree=50, importance=T)
head(TAP.AX)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
setwd("C:\\Documents and Settings\\Macro\\Desktop\\Ivandata\\Predicting-Stock-Market-Returns")
library(xts)
## As the function get.hist.quote() returns an object of class zoo, we have
## again used the function as.xts() to coerce it to xts.
#     library(tseries)
#     TAP.AX <- as.xts(get.hist.quote("TAP.AX",start="1970-01-02", # end="2009-09-15",
#                                   quote=c("Open", "High", "Low", "Close","Volume","AdjClose")))
#     TAP.AX[c(1,nrow(GSPC))]
## quantmod
library(quantmod)
#     getSymbols("TAP.AX", from = "1970-01-01", to = "2009-09-15")
setSymbolLookup(TAP=list(name='TAP.AX',src='yahoo'),
IBM=list(name='IBM',src='yahoo'),
USDEUR=list(name='USD/EUR',src='oanda'))
getSymbols(c('TAP.AX'))
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
head(TAP.AX)
#     saveSymbolLookup()
#     loadSymbolLookup()
## indicator function
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
# newTA() can be used to create new
# plotting functions for indicators that we wish to include in candlestick graphs.
png("TAP.png")
candleChart(last(TAP.AX, "3 months"), theme = "white", TA = NULL)
avgPrice <- function(p) apply(HLC(p), 1, mean)
addAvgPrice <- newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind <- newTA(FUN = T.ind, col = "red", legend = "tgtRet")
addAvgPrice(on = 1)
addT.ind()
dev.off()
# a representative set of technical indicators, from those available in package TTR
library(TTR)
myATR <- function(x) ATR(HLC(x))[, "atr"]
mySMI <- function(x) SMI(HLC(x))[, "SMI"]
myADX <- function(x) ADX(HLC(x))[, "ADX"]
myAroon <- function(x) aroon(x[, c("High", "Low")])$oscillator
myBB <- function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol <- function(x) Delt(chaikinVolatility(x[, c("High", "Low")]))[, 1]
myCLV <- function(x) EMA(CLV(HLC(x)))[, 1]
myEMV <- function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD <- function(x) MACD(Cl(x))[, 2]
myMFI <- function(x) MFI(x[, c("High", "Low", "Close")], x[, "Volume"])
mySAR <- function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat <- function(x) volatility(OHLC(x), calc = "garman")[,1]
# Build a random forest using the data available for training:
library(randomForest)
TAP.AX <- HLC(TAP.AX)
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
TAP.AX
setwd("C:\\Documents and Settings\\Macro\\Desktop\\Ivandata\\Predicting-Stock-Market-Returns")
library(xts)
## As the function get.hist.quote() returns an object of class zoo, we have
## again used the function as.xts() to coerce it to xts.
#     library(tseries)
#     TAP.AX <- as.xts(get.hist.quote("TAP.AX",start="1970-01-02", # end="2009-09-15",
#                                   quote=c("Open", "High", "Low", "Close","Volume","AdjClose")))
#     TAP.AX[c(1,nrow(GSPC))]
## quantmod
library(quantmod)
#     getSymbols("TAP.AX", from = "1970-01-01", to = "2009-09-15")
setSymbolLookup(TAP=list(name='TAP.AX',src='yahoo'),
IBM=list(name='IBM',src='yahoo'),
USDEUR=list(name='USD/EUR',src='oanda'))
getSymbols(c('TAP.AX'))
colnames(TAP.AX) <- c("Open", "High", "Low", "Close", "Volume", "Adjusted")
head(TAP.AX)
#     saveSymbolLookup()
#     loadSymbolLookup()
## indicator function
T.ind <- function(quotes, tgt.margin = 0.025, n.days = 10) {
v <- apply(HLC(quotes), 1, mean) # HLC()-subset High, Low and Close. Apply - calculate avg of those three by row
r <- matrix(NA, ncol = n.days, nrow = nrow(quotes)) # nrow * n.days matrix with NA
for (x in 1:n.days) r[, x] <- Next(Delt(v, k = x), x) # Delt() - calculate the k-period percent diff between n and n+x.
x <- apply(r, 1, function(x) sum(x[x > tgt.margin | x < -tgt.margin])) # sum % change larger than 0.025 in r, if >0 good, <0 bad.
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
# newTA() can be used to create new
# plotting functions for indicators that we wish to include in candlestick graphs.
png("TAP.png")
candleChart(last(TAP.AX, "3 months"), theme = "white", TA = NULL)
avgPrice <- function(p) apply(HLC(p), 1, mean)
addAvgPrice <- newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind <- newTA(FUN = T.ind, col = "red", legend = "tgtRet")
addAvgPrice(on = 1)
addT.ind()
dev.off()
# a representative set of technical indicators, from those available in package TTR
library(TTR)
myATR <- function(x) ATR(HLC(x))[, "atr"]
mySMI <- function(x) SMI(HLC(x))[, "SMI"]
myADX <- function(x) ADX(HLC(x))[, "ADX"]
myAroon <- function(x) aroon(x[, c("High", "Low")])$oscillator
myBB <- function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol <- function(x) Delt(chaikinVolatility(x[, c("High", "Low")]))[, 1]
myCLV <- function(x) EMA(CLV(HLC(x)))[, 1]
myEMV <- function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD <- function(x) MACD(Cl(x))[, 2]
myMFI <- function(x) MFI(x[, c("High", "Low", "Close")], x[, "Volume"])
mySAR <- function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat <- function(x) volatility(OHLC(x), calc = "garman")[,1]
# Build a random forest using the data available for training:
library(randomForest)
TAP.AX$Volumn <- TAP.AX$Volumn+0.000000001
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
TAP.AX$Volume <- TAP.AX$Volume+0.000000001
TAP.AX
data.model <- specifyModel(T.ind(TAP.AX) ~ Delt(Cl(TAP.AX),k=1:10) +
myATR(TAP.AX) + mySMI(TAP.AX) + myADX(TAP.AX) + myAroon(TAP.AX) +
myBB(TAP.AX) + myChaikinVol(TAP.AX) + myCLV(TAP.AX) +
CMO(Cl(TAP.AX)) + EMA(Delt(Cl(TAP.AX))) + myEMV(TAP.AX) +
myVolat(TAP.AX) + myMACD(TAP.AX) + myMFI(TAP.AX) + RSI(Cl(TAP.AX)) +
mySAR(TAP.AX) + runMean(Cl(TAP.AX)) + runSD(Cl(TAP.AX)))
set.seed(1234)
rf <- buildModel(data.model,method='randomForest',
training.per=c(start(TAP.AX),index(TAP.AX["2012-12-31"])),
ntree=50, importance=T)
?specifyModel
ex.model <- specifyModel(T.ind(IBM) ~ Delt(Cl(IBM), k = 1:3))
data <- modelData(ex.model, data.window = c("2009-01-01", "2009-08-10"))
data
varImpPlot(rf@fitted.model, type = 1)
varImpPlot(rf@fitted.model, type = 1)
imp <- varImpPlot(rf@fitted.model, type = 1) #
rownames(imp)[which(imp > 10)]
imp <- importance(rf@fitted.model, type = 1)
rownames(imp)[which(imp > 10)]
Tdata.train <- as.data.frame(modelData(data.model, data.window=c('1970-01-02','2012-12-31')))
Tdata.eval <- na.omit(as.data.frame(modelData(data.model, data.window=c('2012-12-31','2014-08-18'))))
head(Tdata.train)
head(Tdata.eval)
Tdata.eval <- na.omit(as.data.frame(modelData(data.model, data.window=c('2013-01-01','2014-08-18'))))
Tform <- as.formula('T.ind.TAP.AX ~ .')
Tform
set.seed(1234)
library(nnet)
norm.data <- scale(Tdata.train)
head(norm.data)
nn <- nnet(Tform, norm.data[1:1000, ], size = 10, decay = 0.01,maxit = 1000, linout = T, trace = F)
norm.preds <- predict(nn, norm.data[1001:2000, ])
norm.preds <- predict(nn, norm.data[1001:1900, ])
norm.data
norm.preds <- predict(nn, norm.data[1001:nrow(norm.data), ])
preds <- unscale(norm.preds, norm.data)
preds <- rescale(norm.preds, norm.data)
?scale
?unscale
install.packages("DMwR")
library(DMwR)
preds <- unscale(norm.preds, norm.data)
